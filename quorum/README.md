# Quorum机制

如果对于PBFT共识算法有所了解，对两种基本关系可能会比较熟悉：在系统内最多存在f个错误节点的前提下，系统内总节点数量n应该满足n>3f，在推进共识过程中则需要收集一定数目的投票，才能完成认证过程。在本节当中，我们将首先讨论这些数值间关系该如何得出。

在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是在同一时刻，一个数据对象的多份拷贝只能用于读或者写。为了保持数据冗余与一致性，需要对应的投票机制进行维持，这就是Quorum机制。区块链作为一种分布式系统，同样也需要该机制进行集群维护。

为了更好地理解Quorum机制，我们先来了解一种与之类似，但是更加极端的投票机制——**WARO机制（Write All Read One）**。使用WARO机制维护节点总数为n的集群时，节点执行写操作的“票数”应当为n，而读操作时的“票数”可以设置为1。也就是说，在执行写入时，需要保证全部节点完成写入操作才可视该操作为完成，否则会写入失败；相应地，在执行读操作时，只需要读取一个节点的状态，就可以对该系统状态进行确认。可以看到，在使用WARO机制的集群中，写操作的执行非常脆弱：只要有一个节点执行写入失败，那么这次操作就无法完成。不过，虽然牺牲了写操作健壮性，但是，在WARO机制下，对于该集群执行读操作会非常容易。

**Quorum机制**[1]就是对读写操作的折衷考虑，对于同一份数据对象的每一份拷贝，不会被超过两个访问对象读写，并且权衡读写时的集合大小要求。在一个分布式集群当中，每一份数据拷贝对象都被赋予了一票。假设：

- 系统中有**V票**，这就意味着一个数据对象有V份冗余拷贝；

- 对于每一个读操作，获得的票数必须大于**最小读票数R**（read quorum）才可以成功读取；

- 对于每个写操作，获得的票数必须大于**最小写票数W**（write quorum）才可以成功写入。

此时，为了维持集群一致性，V、R、W应满足不等关系，R+W>V且W>V/2。

其中，R+W>V保证了一个数据不会被同时读或写。当一个写操作请求传入，它必须要获得W票，而剩下的数量是V-W不足R，因此不会再处理读请求。同理，当读请求已经获得了R票，写请求就无法被处理。W>V/2，保证了数据的串行修改，也就是说，一份数据的冗余拷贝不可能同时被两个写请求修改。

对于集群中的共识节点，在推进共识算法时，参与共识的节点会同时对集群进行读写操作。为了平衡读写操作对于集合大小的要求，每个节点的R与W取同样大小，记为Q。当集群中总共存在**n个节点**，并且其中**最多出现f个错误**节点的情况下，我们该如何计算n、f、Q之间的关系呢？接下来，我们将从最简单的CFT场景出发，逐步探索如何在BFT场景中得到这些数值取值之间的关系。

### CFT

CFT（Crash Fault Tolerance），表示系统中的节点只会出现**宕机（Crash）**这种错误行为，任何节点不会主动发出错误消息。当我们在讨论共识算法可靠性时，通常会关注算法的两种基本性质：**活性（liveness）**与**安全性（safety）**。在计算Q的大小时，同样也可以从这两个角度出发进行考虑。

对于活性与安全性，有一种比较直观的描述方式：

- *something eventually happens*[2]，某个事件**最终会**发生

- *something good eventually happens*[2]，这个最终会发生的事件**合理**

从活性角度出发，我们的集群需要能够持续运行下去，不会由于某些节点的错误导致无法继续共识。从安全性角度出发，我们的集群在共识推进的过程中，能够持续获得某个合理的结果，对于分布式系统来说，这种“合理”的结果，其最基本的要求就是集群整体状态的一致性。

于是，在CFT场景下，对于Q数值的确定就变得简单明确：

- 活性：由于我们需要保证集群能够持续运行，所以，在任何场景下都要保证有获取到Q票的可能性，从而为集合读写数据。由于集群中最多会有f个节点发生宕机，所以为了保证能获取到Q票，该值的大小需要满足：Q<=n-f。

- 安全性：由于我们需要保证集群不发生分歧，所以，按照Quorum机制的基本要求，需要满足在上一节当中提到的两个不等式，将Q作为最小读集合与最小写集合带入该组不等式，此时，Q满足不等关系，Q+Q>n且Q>n/2，因此，该值的大小需要满足：Q>n/2。

### BFT

BFT（Byzantine Fault Tolerance），表示集群中的错误节点不仅可能会发生宕机，也可能存在恶意行为，即**拜占庭（Byzantine）**行为，例如主动进行状态分叉。在这种情况下，对于集群整体而言，只有n-f个节点的状态可靠，当我们收集到Q个投票时，其中也只有Q-f个投票来自可靠的节点。因此，在安全性方面，BFT场景下需要保证**状态可靠的节点之间**不会发生分歧，因此得到以下两种关系：

- 活性：依然只需要保证每时每刻都有获取Q票的可能性，因此，Q<=n-f。

- 安全性：对于全部保证正确的节点（总数n-f）不会发生分歧，此时，应当满足不等关系，(Q-f)+(Q-f)>n-f且(Q-f)>(n-f)/2，因此，此时Q的大小需要满足的关系为，Q>(n+f)/2。

### 节点总数与容错上限

对于节点总数n与容错上限f，在PBFT论文当中给出的解释[3]：由于存在f个节点可能发生宕机，因此我们至少需要在收到n-f条消息时进行响应，而对于我们收到的来自n-f个节点的消息，由于其中最多可能存在f条消息来自于不可靠的拜占庭节点，因此需要满足n-f-f>f，所以，**n>3f**。

简单来说，PBFT的作者从集群活性与安全性出发，得到了节点总数与容错上限之间的关系。上一节中，我们也是从活性与安全性角度，获得了n、f与Q的关系，在这里也可以用来推导n与f的关系：为了同时满足活性与安全性的要求，Q需要满足不等关系，Q<=n-f且Q>(n+f)/2，因此，可以得到n与f之间的不等关系，(n+f)/2<n-f，也就是**n>3f**。

(通过类似的方式，也可以得到CFT场景中n与f的关系，n>2f。)


# reference

[1] https://en.wikipedia.org/wiki/Quorum_(distributed_computing)

[2] Owicki S, Lamport L. Proving liveness properties of concurrent programs[J]. ACM Transactions on Programming Languages and Systems (TOPLAS), 1982, 4(3): 455-495.

[3] Castro M, Liskov B. Practical Byzantine fault tolerance[C]//OSDI.1999, 99(1999): 173-186.
